<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div>




    2020年新版，对部分组件的描述进行了更新。19年文章参见 这里 。如果你在做选型方面的工作，或者想了解一些现在正在流行的技术，那么这篇文章正好适合你。<br/>
    本篇内容涵盖14个方面，涉及上百个框架和工具。会有你喜欢的，大概也会有你所讨厌的家伙。这是我平常工作中打交道最多的工具，大小公司都适用。如果你有更好的，欢迎留言补充。<br/>
    一、消息队列<br/>
    二、缓存<br/>
    三、分库分表<br/>
    四、数据同步<br/>
    五、通讯<br/>
    六、微服务<br/>
    七、分布式工具<br/>
    八、监控系统<br/>
    九、调度<br/>
    十、入口工具<br/>
    十一、OLT（A）P<br/>
    十二、CI/CD<br/>
    十三、问题排查<br/>
    十四、本地工具<br/>
    复制代码<br/>
    一、消息队列<br/>

    √ 推荐：(1) 吞吐量优先选择kafka<br/>
    (2) 稳定性优先选择RocketMQ<br/>
    (3) 物联网：VerneMQ<br/>


    一个大型的分布式系统，通常都会异步化，走消息总线。  消息队列作为最主要的基础组件，在整个体系架构中，有着及其重要的作用。异步通常意味着编程模型的改变，时效性会降低。
    kafka是目前最常用的消息队列，尤其是在大数据方面，有着极高的吞吐量。而rocketmq和rabbitmq，都是电信级别的消息队列，在业务上用的比较多。相比较而言，ActiveMQ使用的最少，属于较老一代的消息框架。
    pulsar是为了解决一些kafka上的问题而诞生的消息系统，比较年轻，工具链有限。有些激进的团队经过试用，反响不错，但实际使用并不多。
    mqtt具体来说是一种协议，主要用在物联网方面，能够双向通信，属于消息队列范畴，推荐使用vernemq。
    相关文章：
    「整体」分布式消息系统，设计要点。画龙画虎难画骨
    「Kafka」Kafka基础知识索引
    「Kafka」 360度测试：KAFKA会丢数据么？其高可用是否满足需求？
    「Kafka」 使用多线程增加kafka消费能力
    「AMQ」ActiveMQ架构设计与最佳实践，需要一万字
    「MQ」开源一个kafka增强：okmq-1.0.0<br/>
    二、缓存<br/>

    √ 推荐：(1)  堆内缓存使用默认的caffeine<br/>
    (2) 分布式缓存采用redis的cluster集群模式，但要注意使用限制<br/>


    数据缓存是减少数据库压力的有效途径，有单机java内缓存，和分布式缓存之分。<br/>
    对于单机来说，guava的LoadingCache和ehcache都是些熟面孔，不过SpringBoot选择了caffeine作为它的默认堆内缓存，这是因为caffeine的速度比较快的原因。<br/>
    对于分布式缓存来说，优先选择的就是redis，别犹豫。由于redis是单线程的（6.0支持多线程，但默认不开启），并不适合高耗时操作。所以对于一些数据量比较大的缓存，比如图片、视频等，使用老牌的memcached效果会好的多。
    JetCache是一个基于Java的缓存系统封装，提供统一的api和注解来简化缓存的使用。类似SpringCache，支持本地缓存和分布式缓存，也是简化开发的利器。<br/>
    相关文章：<br/>
    「Redis」这可能是最中肯的Redis规范了<br/>
    「Redis」与亲生的Redis Cluster，来一次亲密接触<br/>
    「Redis」redis的zset有多牛？请把耳朵递过来<br/>
    「Redis」好慌，Redis这么多集群方案，要用哪种？<br/>
    「协议」架构秘笈：移花接木。使用mysql模拟redis<br/>
    「Redis」Redis都要老了，你还在用什么古董客户端？<br/>
    「堆内」新一代缓存Caffeine，速度确实比Guava的Cache快<br/>
    三、分库分表<br/>

    √ 推荐：shardingsphere中的sharding-jdbc<br/>


    分库分表，几乎每一个上点规模的公司，都会有自己的方案。目前，推荐使用驱动层的sharding-jdbc（已经进入apache），或者代理层的mycat。如果你没有额外的运维团队，又不想花钱买其他机器，那么就选前者。
    如果分库分表涉及的项目不多，spring的动态数据源是一个非常好的选择。它直接编码在代码里，直观但不易扩展。<br/>
    如果只需要读写分离 ，那么mysql官方驱动里的replication协议，是更加轻量级的选择。<br/>
    上面的分库分表组件，都是大浪淘沙，最终的优胜品。这些组件不同于其他组件选型，方案一旦确定，几乎无法回退，所以要慎之又慎。<br/>
    分库分表是小case，准备分库分表的阶段，才是重点：也就是数据同步。<br/>
    相关文章：<br/>
    「分库分表」“分库分表” ？选型和流程要慎重，否则会失控<br/>
    「数据同步」希望一个数据同步，包治百病<br/>
    「分库分表」分库分表“实践”大全<br/>
    「HA」”MySQL官方驱动“主从分离的神秘面纱<br/>
    「Sharding」 现实中的路由规则，可能比你想象中复杂的多<br/>
    「Sharding」 非规范SQL的sharding-jdbc实践<br/>
    四、数据同步<br/>

    √ 推荐：canal<br/>


    国内使用mysql的公司居多，但postgresql凭借其优异的性能，使用率逐渐攀升。<br/>
    不管什么数据库，实时数据同步工具，都是把自己模拟成一个从库，进行数据拉取和解析。 具体来说，mysql是通过binlog进行同步；postgresql使用wal日志进行同步。<br/>
    对mysql来说，canal是国内用的最多的方案；类似的databus也是比较好用的工具。<br/>
    现在，canal、maxwell等工具，都支持将要同步的数据写入到mq中，进行后续处理，方便了很多。<br/><br/>
    对于ETL（抽取、清洗、转换）来说，基本上都是source、task、sink路线，与前面的功能对应。gobblin、datax、logstash、sqoop等，都是这样的工具。<br/>
    它们的主要工作，就是怎么方便的定义配置文件，编写各种各样的数据源适配接口等。这些ETL工具，也可以作为数据同步（尤其是全量同步）的工具，通常是根据ID，或者最后更新时间 等，进行处理。<br/>
    binlog是实时增量工具，ETL工具做辅助。通常一个数据同步功能，需要多个组件的参与，他们共同组成一个整体。<br/>
    相关文章：<br/>
    「云库」MySQL痿了，放不下这么多数据！<br/>
    「数据同步」由 Canal 组件分析集成中间件架构的一般过程<br/>
    「云库」记一次操蛋的方案降级（云上冷热分离的坎坷之路）<br/>
    五、通讯<br/>

    √ 推荐：http+json，方便调试。高性能要求可选二进制协议<br/>


    Java 中，netty已经成为当之无愧的网络开发框架，包括其上的socketio（不要再和我提mina了）。对于http协议，有common-httpclient，以及更加轻量级的工具okhttp来支持。
    对于一个rpc来说，要约定一个通讯方式和序列化方式。json是最常用的序列化方式，但是传输和解析成本大，xml等文本协议与其类似，都有很多冗余的<br/>


</div>
</body>
</html>